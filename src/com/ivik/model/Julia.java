package com.ivik.model;

import com.ivik.util.IterableFunction;

import java.awt.*;
import java.awt.image.BufferedImage;

/**
 * Created by Sir Royal Air Benny on 7-3-2016.
 */
public class Julia implements IterableFunction {
    private double startX;
    private double startY;
    private double width;
    private double height;

    private int pixelRows;
    private int pixelColumns;
    private int maxIterations;

    private int[][] counts;

    private double dX;
    private double dY;

    private BufferedImage image;

    public Julia(double sX, double sY, double w, double h, int rows, int cols, int max) {
        startX = sX;
        startY = sY;
        width = w;
        height = h;
        pixelRows = rows;
        pixelColumns = cols;
        maxIterations = max;

        dX = width / (cols-1);
        dY = height / (rows-1);

        counts = new int[pixelRows][pixelColumns];

        iterateFunction();
    }

    @Override
    public void iterateFunction() {
        image = new BufferedImage(pixelRows, pixelColumns, BufferedImage.TYPE_INT_RGB);

        int black = 0;
        int[] colors = new int[maxIterations];
        for (int i = 0; i<maxIterations; i++) {
            colors[i] = Color.HSBtoRGB(i/256f, 1, i/(i+8f));
        }

        for (int i = 0; i < pixelRows; i++) {
            for (int j = 0; j < pixelColumns; j++) {

                // Julia set fractals are normally generated by initializing a complex number  z = x + yi
                // where  i2 = -1  and x and y are image pixel coordinates in the range of about -2 to 2.
                // Then, z is repeatedly updated using:  z = z2 + c
                // where c is another complex number that gives a specific Julia set.
                // After numerous iterations, if the magnitude of z is less than 2 we say that pixel is
                // in the Julia set and color it accordingly.
                // Performing this calculation for a whole grid of pixels gives a fractal image.

                double z_re = startX + j * dX;
                double z_im = startY - i * dY;
                Complex z = new Complex(z_re, z_im);
                Complex c = new Complex(-0.79, 0.15); //-0.79, 0.15

                int iterations = 0;

                while(true) {
                    // f(x) = xÂ² + c
                    z = (z.times(z)).plus(c);
                    iterations++;
                    if(iterations > maxIterations || z.modulus() > 2) break;
                }
                if (iterations >= maxIterations) {
                    counts[i][j] = 0;
                    image.setRGB(j, i, black);
                } else {
                    counts[i][j] = iterations;
                    image.setRGB(j, i, colors[iterations]);
                }
            }
        }
        //try {
        //   ImageIO.write(image, "png", new File("src/com/ivik/resources/"+fileName));
        //} catch (IOException e) {
        //    e.printStackTrace();
        //}
    }

    public double getStartX() {
        return startX;
    }

    public double getStartY() {
        return startY;
    }

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    public int getPixelRows() {
        return pixelRows;
    }

    public int getPixelColumns() {
        return pixelColumns;
    }

    public int getMaxIterations() {
        return maxIterations;
    }

    public int[][] getCounts() {
        return counts;
    }

    public double getdX() {
        return dX;
    }

    public double getdY() {
        return dY;
    }

    public BufferedImage getImage() {
        return image;
    }
}
